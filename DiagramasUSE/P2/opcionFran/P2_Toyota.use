-- =====================================================================
--                             MODELO
-- =====================================================================

model P2_Toyota

-- =====================================================================
--                           ENUMERATIONS
-- =====================================================================

enum TipoRevision{Mantenimiento, Reparacion}


-- =====================================================================
--                             CLASES
-- =====================================================================

class Clock
attributes
    NOW : Integer --init = 0                    -- Nos dice el dia actual en el que se encuentra el sistema
    resolution : Integer --init = 1
operations
    tick()
    begin
    end

    run(n : Integer)
    begin
    end
end

abstract class ActiveObject
operations
    tick()
    begin
    end
end

class Coche < ActiveObject
attributes
    velocidad : Integer
    kmRecorridos : Real derive :              -- Registro de todos los km que ha recorrido el coche entre ciudades en sus viajes
        self.viaje.recorrido -> collect(dist | dist.distancia) -> sum()
    fechaMatriculacion : Integer              -- Fecha en la que el coche se puso en funcionamiento en nuestro sistema
    necesitaMantenimiento : Boolean derive :  -- Flag que indica que el coche necesita ir a revisión Tipo: Mantenimiento
        -- razones de necesitaMantenimiento
        not ((self.clock -> asOrderedSet() -> first()).NOW - (self.revision -> collect(rev | revision.fechaFin) -> max()) < 100) or 
        not (fechaMatriculacion < 400)
    enGarantia : Boolean derive :             -- Flag que indica que el coche tiene una garantia activa
        -- razones por estar enGarantia
        (fechaMatriculacion < 400) or
        (validezDeGarantia > 0)
    validezDeGarantia : Integer derive :      -- Días por los que la garantia proporcionada por un tallerOficial esta activa
        let revOrdenadas : OrderedSet(Revision) = self.revision -> sortedBy(fechaFin) in
        (revOrdenadas -> select(rev | rev.taller.oclIsKindOf(Oficial)) -> last()).taller.oclAsType(Oficial).garantia
        
        --self.revision->select(revisionEn | revisionEn.taller.oclIsKindOf(Oficial))->
        --collect(revisionEn | revisionEn.taller.validezGarantia)->last()
end 

class Viaje
attributes
    fechaSalida : Integer                     -- Dia en el que el coche comienza en viaje
    fechaLlegada : Integer               -- Dia en el que el coche finaliza el viaje ESTO EN EL APARTADO B SERA UN DERIVED
        --fechaSalida + ((self.recorrido -> asOrderedSet() -> first()).distancia/self.coche.velocidad)
end

class Revision
attributes
    tipo : TipoRevision                       -- Selecciona el tipo de revisión del enumeration definido
    fechaInicio : Integer                     -- Guarda el registro de cuando inició la revisión del coche
    fechaFin : Integer                        -- Guarda el registro de cuando el coche sale de revisión
end

abstract class Taller                         -- Clase abstracta Taller. No debe tener instancias, solo sus subclases tienen
end

class Oficial < Taller                        -- Taller Oficial hereda de Taller
attributes
    garantia : Integer                        -- Total del dias en lo que el coche estará enGarantia
end

class No_Oficial < Taller                     -- Taller No Oficial hereda de Taller
end 

class Ciudad
attributes
    nombre : String                           -- Nombre de la ciudad
end


-- =====================================================================
--                       CLASES DE ASOCIACIÓN
-- =====================================================================

associationclass Recorrido between
    Ciudad [1..*] role origen
    Ciudad [1..*] role destino
attributes
    distancia : Real                    -- Define el camino de separación entre dos Ciudades distintas
end 

-- =====================================================================
--                         ASOCIACIONES 
-- =====================================================================

association time between
Clock [1] role clock
ActiveObject [0..*] role ao
end

association hace between
Coche [1] role coche
Viaje [0..*] role viaje
end

association realiza between
Viaje [1..*] role viaje
Recorrido [1..*] role recorrido
end

association esta_en between
Coche [0..*] role coche
Ciudad [1] role ciudad
end

composition se_somete between
Coche [1..*] role coche
Revision [*] role revision
end

composition se_realiza between
Revision [1] role revision
Taller [1] role taller
end

composition existe_en between
Taller [0..1] role tallerOficial
Ciudad [1] role ciudadConOficial
end

composition puede_existir between
Taller [0..*] role tallerNoOficial
Ciudad [1] role ciudadConNoOficial
end


-- =====================================================================
--                         INVARIANTES
-- =====================================================================

constraints
-- Invariante 1: Cada cuidad debe tener una distancia minima de 5 km de la otra.
context Recorrido
    inv minimo5Km:
    self.distancia >= 5

-- Invariante 2: Cada coche debe de pasar revision despues de matricularse y no antes.
context Coche
    inv revisionDespuesdeMatriculacion:
    self.revision -> forAll(rev | rev.fechaInicio >= self.fechaMatriculacion)

-- Invariante 3: Todos los coches han de ser revisado como maximo en un momento dado.
    inv revisadoUnaVez:
    self.revision -> forAll(rev1, rev2 | rev1.fechaInicio <> rev2.fechaInicio or rev1.fechaInicio >= rev2.fechaFin or rev2.fechaInicio >= rev1.fechaFin)

-- Invariante 4: Si un coche esta en revision, debe de estar en la misma ciudad que el taller.
    inv mismaCiudadqueTallerEnRevision:
    self.necesitaMantenimiento implies self.revision -> exists(t1 | t1.taller.ciudadConOficial = self.ciudad or t1.taller.ciudadConNoOficial = self.ciudad)

-- Invariante 5: Un coche tiene que estar o viajando o en una ciudad.
    inv viajandoOenCiudad:
    if self.viaje -> size() > 0 then self.ciudad -> size() = 1
    else self.ciudad.oclIsUndefined()
    endif

-- V2: PARA MODELADO DINAMICO
-- inv viajandoOenCiudad:
--    if self.viaje -> exists(v | v.fechLlegada = 0) then self.ciudad.oclIsUndefined()
--    else self.ciudad -> size() = 1
--    endif
--    Si un viaje no tiene la fecha de llegada esta está a 0    

-- Invariante 6: Un coche después de su viaje tiene que encontrarse en su ciudad destino.
context Viaje
    inv enCiudadDestino:
    self.recorrido -> exists(r | r.destino -> asOrderedSet() -> includes(self.coche.ciudad -> asOrderedSet() -> first()))

-- Invariante 7: No pueden haber dos viajes solapados.
context Coche
    inv viajeUnico:
    self.viaje -> forAll(v1,v2 | v1.fechaSalida <> v2.fechaSalida and (v1.fechaLlegada <= v2.fechaSalida or v2.fechaLlegada <= v1.fechaSalida))

-- Invariante 8: Un coche debe de empezar el siguiente viaje en la ciudad destino del anterior.
    inv destinoComoOrigen:
    let viajesOrdenados : OrderedSet(Viaje)  = self.viaje -> sortedBy(v | v.fechaSalida) in 
    viajesOrdenados -> forAll(v1, v2 | viajesOrdenados->indexOf(v1) = viajesOrdenados->indexOf(v2) + 1 implies v1.recorrido.destino 
    -> asOrderedSet()-> last() = v2.recorrido.origen -> asOrderedSet()-> first())

-- Invariante 9: Un coche esta en garantia si no pasaron 4 años desde su matriculacion.
    inv enGarantiaMatriculacion:
    self.enGarantia implies self.fechaMatriculacion < 400

-- Invariante 10: Un coche esta en garantia si no han pasado los dias indicados en la garantia de un taller oficial donde el coche tuvo una revision.
    inv enGarantiaRevision:
    self.enGarantia implies self.revision -> exists(rev | rev.taller.oclIsKindOf(Oficial) and ( (self.clock -> asOrderedSet() -> first()).NOW - rev.fechaFin) < rev.taller.oclAsType(Oficial).garantia)

-- Invariante 11-12: Durante los primeros cuatro años desde la fecha de matriculación, un coche no necesita mantenimiento. 
-- Después de ese tiempo, un coche no necesita mantenimiento hasta pasado un año de la última revisión de mantenimiento que tuviera, sin importar el taller donde se realizó
context Coche
    inv mantenimientoMatriculacion:
    self.fechaMatriculacion < 400 implies not self.necesitaMantenimiento

    inv mantenimientoRevision:
    (self.clock -> asOrderedSet() -> first()).NOW - (self.revision -> asOrderedSet() -> sortedBy(fechaFin) -> last()).fechaFin < 100 implies not self.necesitaMantenimiento 
     
-- Invariante 13: Una ciudad tiene que tener un recorrido con otra ciudad de manera obligatoria
context Ciudad
    inv hayRecorridos:
    not (self.origen -> isEmpty()) implies self.destino -> size() > 0