-- =====================================================================
--                             MODELO
-- =====================================================================

model P2_Toyota

-- =====================================================================
--                           ENUMERATIONS
-- =====================================================================

enum TipoRevision{Mantenimiento, Reparacion}


-- =====================================================================
--                             CLASES
-- =====================================================================

class Clock
attributes
    NOW : Integer init : 0                    -- Nos dice el dia actual en el que se encuentra el sistema
    resolution : Integer init : 1
operations
    tick()
    begin
        self.NOW := self.NOW + self.resolution
    end
    post sumaTiempo: self.NOW = self.NOW@pre + self.resolution

    run(n : Integer)
    begin
        for i in Sequence{1..n} do
            self.tick()
        end;
    end
    pre esPositivo: n > 0
    post sumaCorrecta: self.NOW = self.NOW@pre + n
end

abstract class ActiveObject
operations
    tick()
    begin
    end
end

class Coche < ActiveObject
attributes
    velocidad : Integer init : 1
    kmViajeActual : Integer init = 0
    kmRecorridos : Real derive :              -- Registro de todos los km que ha recorrido el coche entre ciudades en sus viajes
        self.viaje.recorrido -> collect(dist | dist.distancia) -> sum() --
    fechaMatriculacion : Integer              -- Fecha en la que el coche se puso en funcionamiento en nuestro sistema
    necesitaMantenimiento : Boolean derive :  -- Flag que indica que el coche necesita ir a revisión Tipo: Mantenimiento
        -- razones de necesitaMantenimiento
        let currentTime : Integer = self.clock.NOW in
        not ((currentTime - fechaMatriculacion) < 400) or 
        not ((currentTime - (self.revision -> collect(rev | revision.fechaFin) -> max())) < 100) --
        
    enGarantia : Boolean derive :             -- Flag que indica que el coche tiene una garantia activa
        -- razones por estar enGarantia
        ((self.clock.NOW  - fechaMatriculacion) < 400) or
        (validezDeGarantia > 0)
    validezDeGarantia : Integer derive :      -- Días por los que la garantia proporcionada por un tallerOficial esta activa
        let revOrdenadas : OrderedSet(Revision) = self.revision -> sortedBy(fechaFin) in
        (revOrdenadas -> select(rev | rev.taller.oclIsKindOf(Oficial)) -> last()).taller.oclAsType(Oficial).garantia
        
        --self.revision->select(revisionEn | revisionEn.taller.oclIsKindOf(Oficial))->
        --collect(revisionEn | revisionEn.taller.validezGarantia)->last()
operations
    acelerar(n : Integer)
    begin
        self.velocidad := self.velocidad + n;
    end
    pre sumandoValido : n > 0
    post sumaCorrecta : self.velocidad = self.velocidad@pre + n

    avanzar()
    begin    
    if self.kmViajeActual + self.velocidad >= (self.viaje -> asOrderedSet() -> sortedBy(v | v.fechaSalida) -> last()).recorrido.distancia then
        self.kmViajeActual := (self.viaje -> asOrderedSet() -> sortedBy(v | v.fechaSalida) -> last()).recorrido.distancia;
        self.finalizarViaje();
    else
        self.kmViajeActual := self.kmViajeActual + self.velocidad;
        end;
    end  
    pre estaEnViaje: (self.viaje -> asOrderedSet() -> sortedBy(fechaSalida) -> last()).fechaLlegada = null and self.ciudad.oclIsUndefined()
    post nuevoKm: self.kmViajeActual = self.kmViajeActual@pre + velocidad

    iniciarViaje(recorrido : Recorrido)
    begin
        declare v : Viaje;
        v.fechaSalida := self.clock.NOW;
        insert (self,v) into realiza;
        insert(v, recorrido) into recorre;
        delete(self, self.ciudad) from estaEn;
    end
    pre estaLibre : not(self.oclIsUndefined()) and (self.revision -> asOrderedSet() -> sortedBy(rev | rev.fechaInicio) -> last()).fechaFin <> null
    post fueraCiudad: self.ciudad.oclIsUndefined()
    --ESTO ES UNA FUNCION PRIVADA NO SE DEBE DE LLAMAR POR SI SOLA
    finalizarViaje()
    begin
        self.velocidad := 0;
        self.kmViajeActual := 0;
        (self.viaje -> asOrderedSet() -> sortedBy(v | v.fechaSalida) -> last()).fechaLlegada := self.clock.NOW;
        insert(self, (self.viaje -> asOrderedSet() -> sortedBy(v | v.fechaSalida) -> last()).recorrido.destino) into estaEn
    end
    post tieneCiudad: self.ciudad -> size() = 1
end 

class Viaje
attributes
    fechaSalida : Integer                     -- Dia en el que el coche comienza en viaje
    fechaLlegada : Integer               -- Dia en el que el coche finaliza el viaje ESTO EN EL APARTADO B SERA UN DERIVED
        --fechaSalida + ((self.recorrido -> asOrderedSet() -> first()).distancia/self.coche.velocidad)
end

class Revision
attributes
    tipo : TipoRevision                       -- Selecciona el tipo de revisión del enumeration definido
    fechaInicio : Integer                     -- Guarda el registro de cuando inició la revisión del coche
    fechaFin : Integer                        -- Guarda el registro de cuando el coche sale de revisión
end

abstract class Taller                         -- Clase abstracta Taller. No debe tener instancias, solo sus subclases tienen
end

class Oficial < Taller                        -- Taller Oficial hereda de Taller
attributes
    garantia : Integer                        -- Total del dias en lo que el coche estará enGarantia
end

class No_Oficial < Taller                     -- Taller No Oficial hereda de Taller
end 

class Ciudad
attributes
    nombre : String                           -- Nombre de la ciudad
end


-- =====================================================================
--                       CLASES DE ASOCIACIÓN
-- =====================================================================

associationclass Recorrido between
    Ciudad [1] role origen
    Ciudad [1] role destino
attributes
    distancia : Integer                    -- Define el camino de separación entre dos Ciudades distintas
end 

-- =====================================================================
--                         ASOCIACIONES 
-- =====================================================================

association time between
Clock [1] role clock
ActiveObject [*] role ao
end

association realiza between
Coche [1] role coche
Viaje [*] role viaje
end

association recorre between
Viaje [*] role viaje
Recorrido [1] role recorrido
end

association estaEn between
Coche [*] role coche
Ciudad [1] role ciudad
end

association esSometido between
Coche [1] role coche
Revision [*] role revision
end

composition esRealizada between
Revision [*] role revision
Taller [1] role taller
end

composition existeOficial between
Ciudad [1] role ciudad
Oficial [0..1] role oficial
end

composition existeNoOficial between
Ciudad [1] role ciudad
No_Oficial [*] role  noOficial
end


-- =====================================================================
--                         INVARIANTES
-- =====================================================================

constraints
-- Invariante 1: Cada cuidad debe tener una distancia minima de 5 km de la otra.
context Recorrido
    inv minimo5Km:
    self.distancia >= 5

-- Invariante 2: Cada coche debe de pasar revision despues de matricularse y no antes.
context Coche
    inv revisionDespuesdeMatriculacion:
    self.revision -> forAll(rev | rev.fechaInicio > self.fechaMatriculacion)

-- Invariante 3: Todos los coches han de ser revisados como máximo en un momento dado.
    inv revisadoUnaVez:
    self.revision -> forAll(rev1, rev2 | rev1.fechaInicio <> rev2.fechaInicio and (rev1.fechaInicio >= rev2.fechaFin or rev2.fechaInicio >= rev1.fechaFin))

-- Invariante 4: Si un coche esta en revision, debe de estar en la misma ciudad que el taller.
    --Versión context Coche
        --inv mismaCiudadqueTallerEnRevision:
        --let ultimaRevision : Integer = (self.revision -> asOrderedSet(Revision) -> sortedBy(fechaFin) -> last()) in
        --((self.clock -> asOrderedSet() -> first()).NOW - ultimaRevision.fechaFin) < 0  implies if ultimaRevision.taller.oclIsKindOf(Oficial) then
        --ultimaRevision.taller.oclAsType(Oficial).ciudad = self.ciudad else ultimaRevision.taller.oclAsType(No_Oficial).ciudad = self.ciudad endif
    --Versión context Revision
context Revision
    inv mismaCiudadqueTallerEnRevision:
    ((self.coche.clock -> asOrderedSet() -> first()).NOW - self.fechaFin) < 0 implies
    (self.taller.oclIsKindOf(Oficial) and self.taller.oclAsType(Oficial).ciudad = self.coche.ciudad) or (self.taller.oclIsKindOf(No_Oficial) and self.taller.oclAsType(No_Oficial).ciudad = self.coche.ciudad)
    --Toda esta comprobación y casting se debe a la desción de modelar la multiplicidad de tallerOFicial en ciudad mediante composiciones específicas para cada tipo de taller


-- Invariante 5: Un coche tiene que estar o viajando o en una ciudad.
    --Versión context Coche
    -- inv viajandoOenCiudad:
        --let ultimoViaje : Integer
        --if  ((self.clock -> asOrderedSet() -> first()).NOW - )
        --else self.ciudad.oclIsUndefined()
        --endif
    --Versión context Revision
context Viaje
    inv viajandoOenCiudad:
    ((self.coche.clock -> asOrderedSet() -> first()).NOW - self.fechaLlegada) < 0 implies
    self.coche.oclIsUndefined()
    
-- V2: PARA MODELADO DINAMICO
-- inv viajandoOenCiudad:
--    if self.viaje -> exists(v | v.fechLlegada = 0) then self.ciudad.oclIsUndefined()
--    else self.ciudad -> size() = 1
--    endif
--    Si un viaje no tiene la fecha de llegada esta está a 0    

-- Invariante 6: Un coche después de su viaje tiene que encontrarse en su ciudad destino.
context Coche
    inv enCiudadDestino:
    let ultimoViaje : Viaje = self.viaje -> asOrderedSet() -> sortedBy(fechaLlegada) -> last() in
    ultimoViaje.recorrido.destino = self.ciudad
    

-- Invariante 7: No pueden haber dos viajes solapados.
context Coche
    inv viajeUnico:
    self.viaje -> forAll(v1,v2 | v1.fechaSalida <> v2.fechaSalida and (v1.fechaLlegada <= v2.fechaSalida or v2.fechaLlegada <= v1.fechaSalida))

-- Invariante 8: Un coche debe de empezar el siguiente viaje en la ciudad destino del anterior.
    inv destinoComoOrigen:
    let viajesOrdenados : OrderedSet(Viaje)  = self.viaje -> sortedBy(v | v.fechaSalida) in 
    viajesOrdenados -> forAll(v1, v2 | viajesOrdenados->indexOf(v1) = viajesOrdenados->indexOf(v2) + 1 implies v1.recorrido.destino 
    = v2.recorrido.origen)
--Las siguientes invariantes ya han sido definidas como argumentos derivados
    -- Invariante 9: Un coche esta en garantia si no pasaron 4 años desde su matriculacion.
        --inv enGarantiaMatriculacion:
        --self.enGarantia implies self.fechaMatriculacion < 400

    -- Invariante 10: Un coche esta en garantia si no han pasado los dias indicados en la garantia de un taller oficial donde el coche tuvo una revision.
        --inv enGarantiaRevision:
        --self.enGarantia implies self.revision -> exists(rev | rev.taller.oclIsKindOf(Oficial) and ( (self.clock -> asOrderedSet() -> first()).NOW - rev.fechaFin) < rev.taller.oclAsType(Oficial).garantia)

    -- Invariante 11-12: Durante los primeros cuatro años desde la fecha de matriculación, un coche no necesita mantenimiento. 
    -- Después de ese tiempo, un coche no necesita mantenimiento hasta pasado un año de la última revisión de mantenimiento que tuviera, sin importar el taller donde se realizó
    --context Coche
        --inv mantenimientoMatriculacion:
        --self.fechaMatriculacion < 400 implies not self.necesitaMantenimiento

        --inv mantenimientoRevision:
        --(self.clock -> asOrderedSet() -> first()).NOW - (self.revision -> asOrderedSet() -> sortedBy(fechaFin) -> last()).fechaFin < 100 implies not self.necesitaMantenimiento 
        
    -- Invariante 10 (antigua 13): Una ciudad tiene que tener un recorrido con otra ciudad de manera obligatoria
context Ciudad
    inv hayRecorridos:
    not (self.origen -> notEmpty() and self.destino -> notEmpty())
    
    -- Invariante 11: Un coche debe de estar en la ciudad origen de un recorrido antes de iniciar un viaje
context Coche
    inv empiezaViajeEnOrigen:
    (self.viaje -> asOrderedSet() -> sortedBy(fechaSalida) -> last()).recorrido.origen = self.ciudad

    -- Invariante 12: Cada coche debe de pasar revision despues de matricularse y no antes.
    inv viajeDespuesdeMatriculacion:
    self.viaje -> forAll(viaje | viaje.fechaSalida > self.fechaMatriculacion)
