\section{Apartado A}
\subsection{Diseño del Código de Andamiaje}
\subsection*{Introducción}
El concepto de \enquote{código de andamiaje} en el diseño orientado a objetos, 
particularmente en Java, hace referencia al conjunto de estructuras y métodos 
necesarios para implementar asociaciones entre clases, asegurando la 
consistencia y la integridad del sistema.\par
\vspace{0.15cm}
Su propósito es proporcionar un marco inicial sobre el que los desarrolladores pueden 
construir las funcionalidades particulares de un proyecto. Sin embargo, la línea entre
\enquote{andamiaje} e \enquote{implementación completa} puede ser fina ya que estamos 
añadiendo nuevas funcionalidades que luego se convierten en el nuevo marco inicial para 
futuros cambios que vayamos a realizar en los próximos apartados. A continuación se 
exponen las decisiones diseño que completan el andamiaje inicial.

\subsection{Análisis de opciones de Diseño}
En esta sección se exponen las diferentes opciones de diseño para la implementación 
del sistema de gestión de un refugio de animales, conforme al modelo de clases y 
operaciones proporcionado.\par
\vspace{0.15cm}
El sistema requiere gestionar los socios del refugio (quienes pueden desempeñar 
diferentes roles como voluntarios, donantes y adoptantes), así como el registro, 
adopción y donación de animales. Además, se deben considerar las relaciones entre 
las entidades (socios, animales, refugio, donaciones) y las restricciones del sistema, 
como la consistencia en los datos y las operaciones.\par
\vspace{0.15cm}
Importante mencionar que en nuestro diseño, \textbf{no hemos aplicado un único enfoque de manera 
exclusiva}. Hemos adoptado una combinación de estrategias dependiendo de las necesidades de 
cada relación dentro del sistema justificándolo de forma adecuada.

\subsubsection{Manejo de las Asociaciones}

\begin{description}
    \item[a)] \textbf{Asociación Directa (Sin Reificación\footnote{
        La reificación es una técnica en programación 
        orientada a objetos que se basa en convertir un 
        concepto abstracto, como una relación, en una 
        entidad concreta o clase.})}
\end{description}

\textit{\textbf{Descripción:}}  
En este enfoque, las asociaciones entre clases se implementan directamente como atributos 
en las clases relacionadas.\par
\vspace{0.15cm}
Esta práctica es fácil de implementar porque la cantidad de clases a gestionar 
y el número de clases necesarias para representar las relaciones es menor. No obstante, 
añadir atributos adicionales a las asociaciones (como fechas en el proceso 
de adopción) puede traer problemas de consistencia al manejar relaciones complejas como la 
de un socio con múltiples roles (lo exploraremos en futuras secciones).\par
\newpage % Para que no se ve aglomerada la definición en la footnote
\textbf{Ejemplo: Implementación de \texttt{Refugio} con asociación directa a \texttt{Animal}}\par
La asociación es directa porque \texttt{Refugio} gestiona los \texttt{Animales} mediante un 
\texttt{set}, sin una clase intermedia que relacione ambas entidades.(ver Código~\ref{codigo:refugio})\par
TODO: CAMBIAR EL CODE\par
En nuestra implementación, hemos decidido la utilización de un \texttt{Set} para las estructuras de datos 
en vez de \texttt{List} por varios factores:

\begin{itemize}
    \item \textbf{Control de elementos repetidos:} Los \texttt{Set} usan los métodos de \texttt{hashCode} e \texttt{equals}
    para hacer la comprobación de la existencia de elementos en la colección. Si un nuevo elemento coincide con uno existente, 
    no se inserta, evitando comprobaciones adicionales que haríamos con el uso de \texttt{List}.
    \item \textbf{Complejidad algorítmica:} En los \texttt{HashSet}, la búsqueda y la inserción tienen una complejidad de \(O(1)\), 
    ya que se basan en tablas hash. Por otro lado, en una \texttt{List} (como \texttt{ArrayList}), las operaciones de búsqueda tienen una 
    complejidad de \(O(n)\), porque requiere iterar sobre los elementos.
    \item \textbf{Orden de los elementos:} En nuestra implementación, no es necesario mantener un orden específico en las colecciones. 
    Por esta razón, el uso \texttt{Set} es más adecuado que \texttt{List} teniendo en cuenta los puntos anteriores.
\end{itemize}
\vspace{0.45cm}

\begin{description}
    \item[b)] \textbf{Reificación de la Asociación (Clase de Asociación)}
\end{description}

\textit{\textbf{Descripción:}}  
En este enfoque, las asociaciones complejas entre clases se modelan mediante clases 
intermedias. Por ejemplo, la clase \texttt{Adopcion} representa la relación entre un 
\texttt{Animal}, un \texttt{Adoptante}, y un \texttt{Voluntario}, incluyendo atributos 
como \texttt{fechaAdopcion} para capturar detalles específicos de la relación.\par
\vspace{0.15cm}
Como la reificación nos permiten agregar atributos y métodos específicos a las relaciones,
facilita la implementación de restricciones complejas relacionadas con la asociación.
Sin embargo, aumenta el número de clases y relaciones a gestionar, lo que hace el diseño más denso
ya que debemos implementar y gestionar las clases de asociación, así como los métodos para 
acceder a las relaciones.\par
\vspace{0.15cm}

\textbf{Nuestra Implementación: Uso de \texttt{Adopcion} como clase de asociación:}
\begin{itemize}
    \item Se representa la relación entre \texttt{Animal}, \texttt{Adoptante} y 
    \texttt{Voluntario} mediante una clase intermedia. (ver Código~\ref{codigo:adopcion})
    \item Atributos como \texttt{fecha} añaden flexibilidad al modelo, permitiendo 
    capturar detalles adicionales de la relación.
    \item Se gestionan las relaciones bidireccionales entre las entidades involucradas, 
    asegurando consistencia en los datos.
\end{itemize}

Elegimos este enfoque, ya que proporciona la flexibilidad necesaria para agregar atributos 
y gestionar reglas de negocio específicas. La asociación directa fue descartada porque no 
permitiría capturar detalles adicionales, como la fecha de adopción, ni manejar eficientemente 
las restricciones relacionadas con el proceso de adopción.



\subsubsection{Manejo de Roles de los Socios}

\begin{description}
    \item[a)] \textbf{Subclases Específicas para cada Rol}
\end{description}

\textit{\textbf{Descripción:}}  
Cada rol (\texttt{Voluntario}, \texttt{Donante}, \texttt{Adoptante}) se implementa como una 
subclase de la clase \texttt{Socio}. Esto permite encapsular los atributos y métodos 
específicos de cada rol dentro de su respectiva subclase.
\vspace{0.15cm}


Esto proporciona claridad al diseño, ya que cada rol está claramente representado con 
métodos específicos para su comportamiento. Además, permite encapsular los atributos y 
métodos particulares de cada tipo de socio, lo que mejora la organización y legibilidad 
del código. Aunque tiene una limitación significativa para manejar roles múltiples, ya que no permite que 
un socio asuma más de un rol sin duplicar instancias de las subclases. Esto hace que el 
diseño sea rígido y menos flexible en casos donde los roles pueden cambiar dinámicamente 
o coexistir (volveremos a hablar de esto en los siguientes apartados).\par
\vspace{0.15cm}



\textbf{Ejemplo: Subclases específicas para los roles}\par
El diseño tiene implementadas las subclases \texttt{Donante}, \texttt{Adoptante}, 
y \texttt{Voluntario} como extensiones de la clase \texttt{Socio}.\par
(ver Código~\ref{codigo:donante}, \ref{codigo:adoptante}, \ref{codigo:voluntario})

\begin{description}
    \item[b)] \textbf{Uso de Composición de Roles}
\end{description}

\textit{\textbf{Descripción:}}  
En lugar de modelar cada rol como una subclase de \texttt{Socio}, este enfoque utiliza 
la composición para permitir que un socio tenga múltiples roles simultáneamente. 
Cada rol se modela como una clase independiente que puede ser asociada dinámicamente a 
un \texttt{Socio} mediante una colección de roles.
\vspace{0.15cm}


Este enfoque es mucho más flexible, ya que permite asignar múltiples roles a un socio 
sin necesidad de crear combinaciones de subclases. También simplifica el manejo de 
roles dinámicos y permite cambios en tiempo de ejecución.
Puede reducir la claridad del diseño, ya que no existe una distinción explícita entre 
los diferentes tipos de socios. Además, requiere implementar lógica adicional para 
validar qué operaciones son aplicables para los roles asignados a cada socio.\par
\vspace{0.15cm}


\textbf{Nuestra implementación: Uso de Subclases Específicas para cada Rol:}\par  
\vspace{0.15cm}
Hemos decidido no cambiar como están implementados los roles mediante subclases específicas 
(para este apartado) en lugar de composición. Esto se debe a que en nuestro modelo actual, 
los roles están claramente definidos y no se requiere que un socio tenga múltiples roles de 
manera simultánea. Además:
\begin{itemize}
    \item La claridad y encapsulación que proporciona la herencia permiten manejar las responsabilidades y comportamientos específicos de cada tipo de socio de manera aislada.
    \item Aunque la composición sería más flexible, introducirá complejidad adicional innecesaria para los requisitos actuales del sistema.
\end{itemize}

No obstante, los requisitos del sistema cambiarán en futuros apartados pidiendo que un socio
tenga múltiples roles simultáneamente. En el apartado correspondiente, se discute porque 
la composición sería una solución más adecuada y como se ha implementado.




\subsubsection{Consistencia y Gestión de Datos}

\begin{description}
    \item[a)] \textbf{Encapsulación Estricta}
\end{description}

\textit{\textbf{Descripción:}}  
Este enfoque restringe el acceso directo a los atributos y métodos de las clases mediante 
el uso de visibilidad privada. Para interactuar con los atributos, se proporcionan métodos 
públicos controlados (\texttt{getters} y \texttt{setters}) que incluyen validaciones (mediante 
\texttt{asserts}) para garantizar que los datos se mantengan en un estado consistente.
\vspace{0.15cm}

    Debido a esto nos aseguramos que los datos sean modificados de manera controlada y consistente.
    Facilita la incorporación de validaciones o pruebas unitarias lo que completa el comportamiento del
    esperado del sistema.Dicho esto también se requiere de implementar más métodos, como \texttt{getters}, \texttt{setters} y validaciones 
    necesarias, lo que aumenta la cantidad de código. Además, estas validaciones podrían hacer 
    que el diseño sea más extenso y menos directo.\par
    \vspace{0.15cm}


\textbf{Ejemplo en el sistema: Uso de encapsulación estricta en la clase \texttt{Animal}:}\par  
En nuestro sistema, la clase \texttt{Animal} utiliza atributos privados y métodos públicos 
controlados para garantizar consistencia y validaciones en tiempo de ejecución.Este enfoque 
asegura que cualquier intento de modificar el estado de un \texttt{Animal} pase por 
validaciones definidas en los métodos públicos. (ver Código~\ref{codigo:animal})


\begin{description}
    \item[b)] \textbf{Uso de Colecciones Inmutables}
\end{description}

\textit{\textbf{Descripción:}}  
En este enfoque, las colecciones utilizadas para representar relaciones (por ejemplo, 
listas o conjuntos de \texttt{Animal} en \texttt{Refugio}) son inmutables. Esto garantiza 
que las relaciones no puedan ser modificadas accidentalmente fuera de las clases que las 
gestionan.
\vspace{0.15cm}

    Mejora la integridad del sistema al garantizar que las relaciones no se modifiquen de 
    manera no controlada.
    Por otro lado introduce rigidez ya que no permite realizar cambios dinámicos en las relaciones sin 
    reemplazar completamente la colección. Esto puede dificultar la gestión de operaciones 
    como agregar o eliminar elementos.\par
    \vspace{0.15cm}

\textbf{Ejemplo de Uso de Colecciones Inmutables en la Clase \texttt{Refugio}:}\par  
En nuestro sistema, el método \texttt{getAnimalesRegistrados} de la clase \texttt{Refugio} 
devuelve una vista inmutable de los animales registrados. Esto asegura que las listas no 
puedan modificarse desde fuera de la clase. Además, el uso de \texttt{Collections.}\texttt{enumeration} 
garantiza que la colección de animales no pueda ser alterada fuera de la clase \texttt{Refugio}, 
manteniendo la consistencia de los datos. (ver Código~\ref{codigo:refugio} aunque se implementa en varias clases)

\textbf{Decisión Tomada: Encapsulación Controlada con Enumerations:}\par
En nuestro diseño, optamos por una encapsulación controlada en lugar de colecciones 
completamente inmutables. Esto se debe a que:
\begin{itemize}
    \item Proporciona flexibilidad para realizar cambios dinámicos en las colecciones a 
    través de métodos controlados, lo que es necesario para operaciones como agregar o 
    eliminar animales en un refugio.
    \item Utilizar enumeraciones en los métodos \texttt{get} garantiza que las colecciones 
    no se modifiquen desde fuera de las clases, preservando la integridad de los datos.
\end{itemize}

Este enfoque combina lo mejor de ambos mundos: flexibilidad para realizar cambios controlados 
y protección contra modificaciones accidentales.



\subsubsection{Estrategias para Manejo de Adopciones y Donaciones}

\begin{description}
    \item[a)] \textbf{Operaciones Independientes}
\end{description}

\textit{\textbf{Descripción:}}  
En este enfoque, cada operación (como adopción, registro de animales o donaciones) se 
implementa de forma independiente, sin interacciones entre ellas. Cada acción tiene su 
propio método o flujo lógico separado.
\vspace{0.15cm}

    Este diseño asegura que las operaciones están bien definidas y separadas, lo que 
    facilita su comprensión. Además, la simplicidad del diseño permite que sea directo y 
    fácil de implementar.Sin Embargo, puede llevar a la duplicación de código si varias operaciones comparten lógica similar 
    (por ejemplo, validar la existencia de un animal o donante). También puede ser menos 
    flexible, ya que cualquier cambio en una operación podría requerir modificaciones en 
    múltiples partes del sistema.\par
    \vspace{0.15cm}

\textbf{Ejemplo: Operaciones independientes en nuestra implementación}  
En nuestro diseño, las adopciones y donaciones se gestionan mediante clases específicas 
(\texttt{Adopcion} y \texttt{Donacion}), cada una con su propia lógica y atributos.

\begin{description}
    \item[b)] \textbf{Reutilización de Lógica Compartida entre Operaciones}
\end{description}

\textit{\textbf{Descripción:}}  
En lugar de mantener las operaciones completamente separadas, este enfoque identifica y 
reutiliza lógica común entre las operaciones (como validaciones o actualizaciones de estado). 
Aunque no implementamos este enfoque en nuestra solución actual, sería posible centralizar las 
validaciones comunes mediante una clase auxiliar, como se muestra en el siguiente ejemplo.\par
\vspace{0.15cm}
Esta opción reduce la duplicación de código, ya que la lógica compartida se implementa una sola vez
y facilita la incorporación de nuevas funcionalidades relacionadas con las operaciones existentes. Pero 
puede introducir una dependencia más estrecha entre las clases, lo que podría aumentar 
la complejidad del sistema en caso de cambios importantes.

\textbf{Ejemplo Propuesto: Centralización de Validaciones}  
Aunque nuestra implementación actual gestiona las validaciones directamente en los métodos 
de las clases relevantes (\texttt{Adoptante}, \texttt{Donante}). Por ejemplo, podríamos considerar una 
clase auxiliar para centralizarlas en el futuro:

\begin{lstlisting}[style = javaEspecifico, language=Java, caption={Clase Auxiliar para Validaciones}] 
public class Validacion {
    public static void validarEstadoAnimal(Animal animal, EstadoAnimal estadoEsperado) {
        assert animal.getEstadoAnimal() == estadoEsperado : 
            "El estado del animal no coincide con el esperado.";
    }
}
\end{lstlisting}

En nuestra implementación actual, la validación se realiza directamente dentro de las clases:

\begin{lstlisting}[style = javaEspecifico, language=Java, caption={Manejo de validaciones dentro del método Adoptar}] 
public void adoptar(Animal a, Voluntario v) {
    assert a.getEstadoAnimal() == EstadoAnimal.DISPONIBLE : 
        "El animal no esta disponible.";
    Adopcion adopcion = new Adopcion(a, this, v, new Date());
    adopciones.add(adopcion);
}
\end{lstlisting}
\vspace{0.15cm}
\textbf{Decisión Tomada: Mantener las Validaciones en las Clases Relevantes}\par
En nuestra implementación actual, las validaciones se realizan directamente en las clases 
donde ocurren las operaciones. Esto se alinea con la claridad y simplicidad requeridas por 
el sistema. Sin embargo, reconocemos que la centralización de lógica compartida podría ser 
útil en sistemas más complejos. FIXME: EL GETTER ES MAL EJEMPLO DE ESTO (ver los getters en Código~\ref{codigo:adopcion} por ejemplo) 



\subsubsection{Representación de Relaciones en el Sistema}

\begin{description}
    \item[a)] \textbf{Relaciones Unidireccionales}
\end{description}

\textit{\textbf{Descripción:}}  
En una relación unidireccional, solo una entidad tiene conocimiento de la relación. 
Por ejemplo, un \texttt{Adoptante} puede conocer al \texttt{Animal} que adopta, 
pero el \texttt{Animal} no necesita saber nada sobre el \texttt{Adoptante}.\par
\vspace{0.15cm} 
Estas relaciones gestionan la relación con una clase, lo que reduce la complejidad del sistema.
El problema, es que limita las consultas entre clases relacionadas y puede volverse más complejo 
añadir funcionalidades.\par
\vspace{0.15cm}
En nuestro sistema, todas las relaciones unidireccionales con 1 a muchos, por ejemplo:
TODO: EXPANDIR ESTA IDEA

\begin{description}
    \item[b)] \textbf{Relaciones Bidireccionales}
\end{description}

\textit{\textbf{Descripción:}}  
En una relación bidireccional, ambas entidades conocen y mantienen referencias mutuas. 
Por ejemplo, cuando un \texttt{Adoptante} adopta un \texttt{Animal}, ambos se actualizan 
mutuamente para reflejar la relación.\par
\vspace{0.15cm}
Las relaciones de este estilo garantizan la consistencia de los datos, ya que ambas partes relacionadas están 
sincronizadas al mantener referencias mutuas explícitas. Sin embargo, como hay que tener una sincronización constante 
entre las todas las clases relacionadas, si tuviéramos muchas relaciones bidireccionales puede dificultar el mantenimiento
por que genera un alto nivel de acoplamiento.\par
\vspace{0.15cm}
\textbf{Ejemplo en el Sistema: Relaciones Bidireccionales en \texttt{Adopcion}}\par 
En nuestro diseño, la relación entre \texttt{Animal}, \texttt{Adoptante}, y 
\texttt{Voluntario} es bidireccional y se asegurando consistencia en ambas direcciones
reflejando los cambios realizados en una clase en las demás involucradas.
(ver Código~\ref{codigo:adopcion} como, por ejemplo, se actualiza el estado del animal tras ser adoptado)\par
\vspace{0.15cm}
\textbf{Decisión Tomada: Relaciones Bidireccionales}\par
Hemos implementado relaciones bidireccionales para las asociaciones complejas del sistema, 
como las adopciones, ya que garantizan consistencia y sincronización entre las entidades 
relacionadas. Sin embargo, para relaciones más simples, como la lista de animales en un 
refugio, usamos relaciones unidireccionales para mantener la simplicidad.

\subsection{Diagrama de Diseño}

\begin{figure}[H]
    \centering
     \includegraphics[width=1\linewidth]{assets/umaLogo.png}
     \caption{UMA}
\end{figure}
FALTA HACER Y METER EL DIAGRAMA DE DISEÑO DE NUESTRO SISTEMA.RECOMENDABLE PONER UNA MINI EXPLICACIÓN.

\newpage



\subsection{Implementación del Modelo}
\input{body/ApartadoA/codigosApartadoA}

\subsection{Conclusión}

El diseño e implementación del código de andamiaje para el sistema se realizó siguiendo 
los principios fundamentales del diseño orientado a objetos, adaptados a los requerimientos 
específicos de este apartado. Se tomaron la decisiones de diseño adecuadas, como la gestión 
de asociaciones entre clases, la encapsulación de datos y la validación restricciones con \texttt{assert}, 
proporcionando un modelo consistente y flexible.\par
\vspace{0.15cm}
Una de las decisiones clave fue el uso combinado de asociaciones directas para relaciones 
simples y la reificación de asociaciones para relaciones más complejas junto con \texttt{get}
con conjuntos inmutables. Esto permitió mantener un equilibrio entre la simplicidad de las 
implementaciones directas, como la gestión de animales en el refugio, y la flexibilidad 
de las relaciones complejas, como las adopciones, donde se requieren atributos adicionales 
y validaciones específicas mientras protegíamos las listas de cada objeto en el sistema.\par
\vspace{0.15cm}
Además, la bidireccionalidad en relaciones como las adopciones, garantizó la 
consistencia del modelo al sincronizar automáticamente los datos entre entidades 
relacionadas.\par
TODO: AÑADIR COMO RESUMEN LAS DESICIONES QUE NO SE HAYANN  MENCIONADO DE LO QUE DIEGO A RECOPILADO EN LLAMADA

\newpage
