\section{Apartado A}
\subsection{Diseño del Código de Andamiaje}
\subsection*{Introducción}
El concepto de \enquote{código de andamiaje} en el diseño orientado a objetos, 
particularmente en Java, hace referencia al conjunto de estructuras, métodos y 
prácticas necesarias para implementar asociaciones entre clases, asegurando la 
consistencia y la integridad del sistema.\par
\vspace{0.15cm}
Su propósito es proporcionar un marco inicial sobre el que los desarrolladores pueden 
construir las funcionalidades particulares de un proyecto, agilizando el desarrollo al 
evitar escribir respectivamente las mismas configuraciones en cada proyecto.

\subsection{Análisis de opciones de Diseño}
En esta sección se discuten las diferentes opciones de diseño para la implementación 
del sistema de gestión de un refugio de animales, conforme al modelo de clases y 
operaciones proporcionado.\par
\vspace{0.15cm}
El sistema requiere gestionar los socios del refugio (quienes pueden desempeñar 
diferentes roles como voluntarios, donantes y adoptantes), así como el registro, 
adopción y donación de animales. Además, se deben considerar las relaciones entre 
las entidades (socios, animales, refugio, donaciones) y las restricciones del sistema, 
como la consistencia en los datos y las operaciones.\par
\vspace{0.15cm}
El diseño del código de andamiaje es crucial para garantizar que el sistema sea flexible, 
sostenible y eficiente. En el siguiente análisis, exploraremos diversas opciones de diseño 
y sus implicaciones para la implementación en Java así como la decisión de diseño tomada y 
su justificación.\par
\vspace{0.15cm}
Importante mencionar que en nuestro diseño, \textbf{no hemos aplicado un único enfoque de manera 
exclusiva}. Hemos adoptado una combinación de estrategias dependiendo de las necesidades de 
cada relación dentro del sistema justificándolo de forma adecuada.

\subsubsection{Manejo de las Asociaciones}

\begin{description}
    \item[a)] \textbf{Asociación Directa (Sin Reificación)}
\end{description}

\textit{\textbf{Descripción:}}  
En este enfoque, las asociaciones entre clases se implementan directamente como atributos 
en las clases relacionadas.\par

\begin{itemize}
    \item \textbf{Ventajas:}\par
    El diseño es directo y fácil de implementar porque tiene menor cantidad de clases a gestionar 
    y minimiza el número de clases necesarias para representar las relaciones.
    \item \textbf{Desventajas:}\par
    No se pueden añadir atributos adicionales a las asociaciones (como fechas en el proceso 
    de adopción) y tiene problemas de consistencia al manejar relaciones complejas como la 
    de un socio con múltiples roles (lo exploraremos en futuras secciones).

\end{itemize}

\textbf{Ejemplo: Implementación de \texttt{Refugio} con asociación directa a \texttt{Animal}}\par
La asociación es directa porque \texttt{Refugio} gestiona los \texttt{Animales} mediante una 
lista o conjunto, sin una clase intermedia que relacione ambas entidades. (ver Código~\ref{codigo:refugio})

\begin{description}
    \item[b)] \textbf{Reificación de la Asociación (Clase de Asociación)}
\end{description}

\textit{\textbf{Descripción:}}  
En este enfoque, las asociaciones complejas entre clases se modelan mediante clases 
intermedias. Por ejemplo, la clase \texttt{Adopcion} representa la relación entre un 
\texttt{Animal}, un \texttt{Adoptante}, y un \texttt{Voluntario}, incluyendo atributos 
como \texttt{fechaAdopcion} para capturar detalles específicos de la relación.

\begin{itemize}
    \item \textbf{Ventajas:}\par
    Se pueden agregar atributos y métodos específicos a las relaciones,
    facilita la implementación de restricciones complejas relacionadas con la asociación y
    permite un manejo más preciso y controlado de las relaciones.
    \item \textbf{Desventajas:}\par
    Incrementa el número de clases y relaciones a gestionar, lo que puede hacer el diseño más denso
    porque ahora debemos implementar y gestionar las clases de asociación, así como los métodos para 
    acceder a las relaciones.
\end{itemize}

\textbf{Nuestra Implementación: Uso de \texttt{Adopcion} como clase de asociación:}
\begin{itemize}
    \item Se representa la relación entre \texttt{Animal}, \texttt{Adoptante} y 
    \texttt{Voluntario} mediante una clase intermedia. (ver Código~\ref{codigo:adopcion})
    \item Atributos como \texttt{fecha} añaden flexibilidad al modelo, permitiendo 
    capturar detalles adicionales de la relación.
    \item Se gestionan las relaciones bidireccionales entre las entidades involucradas, 
    asegurando consistencia en los datos.
\end{itemize}

Elegimos este enfoque, ya que proporciona la flexibilidad necesaria para agregar atributos 
y gestionar reglas de negocio específicas. La asociación directa fue descartada porque no 
permitiría capturar detalles adicionales, como la fecha de adopción, ni manejar eficientemente 
las restricciones relacionadas con el proceso de adopción.



\subsubsection{Manejo de Roles de los Socios}

\begin{description}
    \item[a)] \textbf{Subclases Específicas para cada Rol}
\end{description}

\textit{\textbf{Descripción:}}  
Cada rol (\texttt{Voluntario}, \texttt{Donante}, \texttt{Adoptante}) se implementa como una 
subclase de la clase base \texttt{Socio}. Esto permite encapsular los atributos y métodos 
específicos de cada rol dentro de su respectiva subclase.

\begin{itemize}
    \item \textbf{Ventajas:}\par
    Proporciona claridad al diseño, ya que cada rol está claramente representado con 
    métodos específicos para su comportamiento. Además, permite encapsular los atributos y 
    métodos particulares de cada tipo de socio, lo que mejora la organización y legibilidad 
    del código.
    \item \textbf{Desventajas:}\par
    Tiene una limitación significativa para manejar roles múltiples, ya que no permite que 
    un socio asuma más de un rol sin duplicar instancias de las subclases. Esto hace que el 
    diseño sea rígido y menos flexible en casos donde los roles pueden cambiar dinámicamente 
    o coexistir (volveremos a tocar este tema más adelante).
\end{itemize}

\textbf{Ejemplo: Subclases específicas para los roles}\par
El diseño tiene implementadas las subclases \texttt{Donante}, \texttt{Adoptante}, 
y \texttt{Voluntario} como extensiones de la clase base \texttt{Socio}.\par
(ver Código~\ref{codigo:donante}, \ref{codigo:adoptante}, \ref{codigo:voluntario})

\begin{description}
    \item[b)] \textbf{Uso de Composición de Roles}
\end{description}

\textit{\textbf{Descripción:}}  
En lugar de modelar cada rol como una subclase de \texttt{Socio}, este enfoque utiliza 
la composición para permitir que un socio tenga múltiples roles simultáneamente. 
Cada rol se modela como una clase independiente que puede ser asociada dinámicamente a 
un \texttt{Socio} mediante una colección de roles.

\begin{itemize}
    \item \textbf{Ventajas:}\par
    Este enfoque es mucho más flexible, ya que permite asignar múltiples roles a un socio 
    sin necesidad de crear combinaciones de subclases. También simplifica el manejo de 
    roles dinámicos y permite cambios en tiempo de ejecución.
    \item \textbf{Desventajas:}\par
    Puede reducir la claridad del diseño, ya que no existe una distinción explícita entre 
    los diferentes tipos de socios. Además, requiere implementar lógica adicional para 
    validar qué operaciones son aplicables para los roles asignados a cada socio.
\end{itemize}

\textbf{Nuestra implementación: Uso de Subclases Específicas para cada Rol:}\par  
\vspace{0.15cm}
Hemos decidido no cambiar como están implementados los roles mediante subclases específicas 
(para este apartado) en lugar de composición. Esto se debe a que en nuestro modelo actual, 
los roles están claramente definidos y no se requiere que un socio tenga múltiples roles de 
manera simultánea. Además:
\begin{itemize}
    \item La claridad y encapsulación que proporciona la herencia permiten manejar las responsabilidades y comportamientos específicos de cada tipo de socio de manera aislada.
    \item Aunque la composición sería más flexible, introducirá complejidad adicional innecesaria para los requisitos actuales del sistema.
\end{itemize}

No obstante, los requisitos del sistema cambiarán en futuros apartados pidiendo que un socio
tenga múltiples roles simultáneamente. En el apartado correspondiente, se discute porque 
la composición sería una solución más adecuada y como se ha implementado.




\subsubsection{Consistencia y Gestión de Datos}

\begin{description}
    \item[a)] \textbf{Encapsulación Estricta}
\end{description}

\textit{\textbf{Descripción:}}  
Este enfoque restringe el acceso directo a los atributos y métodos de las clases mediante 
el uso de visibilidad privada. Para interactuar con los atributos, se proporcionan métodos 
públicos controlados (\texttt{getters} y \texttt{setters}) que incluyen validaciones (mediante 
\texttt{asserts}) para garantizar que los datos se mantengan en un estado consistente.

\begin{itemize}
    \item \textbf{Ventajas:}\par
    Asegura que los datos sean modificados de manera controlada y consistente. Facilita la 
    incorporación de validaciones o pruebas unitarias lo que completa el comportamiento del
    esperado del sistema.
    \item \textbf{Desventajas:}\par
    Requiere implementar más métodos, como \texttt{getters}, \texttt{setters} y validaciones 
    necesarias, lo que aumenta la cantidad de código. Además, estas validaciones podrían hacer 
    que el diseño sea más extenso y menos directo.
\end{itemize}

\textbf{Ejemplo en el sistema: Uso de encapsulación estricta en la clase \texttt{Animal}:}\par  
En nuestro sistema, la clase \texttt{Animal} utiliza atributos privados y métodos públicos 
controlados para garantizar consistencia y validaciones en tiempo de ejecución.Este enfoque 
asegura que cualquier intento de modificar el estado de un \texttt{Animal} pase por 
validaciones definidas en los métodos públicos. (ver Código~\ref{codigo:animal})


\begin{description}
    \item[b)] \textbf{Uso de Colecciones Inmutables}
\end{description}

\textit{\textbf{Descripción:}}  
En este enfoque, las colecciones utilizadas para representar relaciones (por ejemplo, 
listas o conjuntos de \texttt{Animal} en \texttt{Refugio}) son inmutables. Esto garantiza 
que las relaciones no puedan ser modificadas accidentalmente fuera de las clases que las 
gestionan.

\begin{itemize}
    \item \textbf{Ventajas:}\par
    Mejora la integridad del sistema al garantizar que las relaciones no se modifiquen de 
    manera no controlada.
    \item \textbf{Desventajas:}\par
    Introduce rigidez, ya que no permite realizar cambios dinámicos en las relaciones sin 
    reemplazar completamente la colección. Esto puede dificultar la gestión de operaciones 
    como agregar o eliminar elementos.
\end{itemize}

\textbf{Ejemplo de Uso de Colecciones Inmutables en la Clase \texttt{Refugio}:}\par  
En nuestro sistema, el método \texttt{getAnimalesRegistrados} de la clase \texttt{Refugio} 
devuelve una vista inmutable de los animales registrados. Esto asegura que las listas no 
puedan modificarse desde fuera de la clase. Además, el uso de \texttt{Collections.}\texttt{enumeration} 
garantiza que la colección de animales no pueda ser alterada fuera de la clase \texttt{Refugio}, 
manteniendo la consistencia de los datos. (ver Código~\ref{codigo:refugio} aunque se implementa en varias clases)

\textbf{Decisión Tomada: Encapsulación Controlada con Enumerations:}\par
En nuestro diseño, optamos por una encapsulación controlada en lugar de colecciones 
completamente inmutables. Esto se debe a que:
\begin{itemize}
    \item Proporciona flexibilidad para realizar cambios dinámicos en las colecciones a 
    través de métodos controlados, lo que es necesario para operaciones como agregar o 
    eliminar animales en un refugio.
    \item Utilizar enumeraciones en los métodos \texttt{get} garantiza que las colecciones 
    no se modifiquen desde fuera de las clases, preservando la integridad de los datos.
\end{itemize}

Este enfoque combina lo mejor de ambos mundos: flexibilidad para realizar cambios controlados 
y protección contra modificaciones accidentales.



\subsubsection{Estrategias para Manejo de Adopciones y Donaciones}

\begin{description}
    \item[a)] \textbf{Operaciones Independientes}
\end{description}

\textit{\textbf{Descripción:}}  
En este enfoque, cada operación (como adopción, registro de animales o donaciones) se 
implementa de forma independiente, sin interacciones entre ellas. Cada acción tiene su 
propio método o flujo lógico separado.

\begin{itemize}
    \item \textbf{Ventajas:}\par
    Este diseño asegura que las operaciones están bien definidas y separadas, lo que 
    facilita su comprensión. Además, la simplicidad del diseño permite que sea directo y 
    fácil de implementar.
    \item \textbf{Desventajas:}\par
    Puede llevar a la duplicación de código si varias operaciones comparten lógica similar 
    (por ejemplo, validar la existencia de un animal o donante). También puede ser menos 
    flexible, ya que cualquier cambio en una operación podría requerir modificaciones en 
    múltiples partes del sistema.
\end{itemize}

\textbf{Ejemplo: Operaciones independientes en nuestra implementación}  
En nuestro diseño, las adopciones y donaciones se gestionan mediante clases específicas 
(\texttt{Adopcion} y \texttt{Donacion}), cada una con su propia lógica y atributos.

\begin{description}
    \item[b)] \textbf{Reutilización de Lógica Compartida entre Operaciones}
\end{description}

\textit{\textbf{Descripción:}}  
En lugar de mantener las operaciones completamente separadas, este enfoque identifica y 
reutiliza lógica común entre las operaciones (como validaciones o actualizaciones de estado). Aunque no implementamos este enfoque en nuestra solución actual, sería posible centralizar las validaciones comunes mediante una clase auxiliar, como se muestra en el siguiente ejemplo.

\begin{itemize}
    \item \textbf{Ventajas:}\par
    Reduce la duplicación de código, ya que la lógica compartida se implementa una sola vez. 
    Además, facilita la incorporación de nuevas funcionalidades relacionadas con las 
    operaciones existentes.
    \item \textbf{Desventajas:}\par
    Puede introducir una dependencia más estrecha entre las clases, lo que podría aumentar 
    la complejidad del sistema en caso de cambios importantes.
\end{itemize}

\textbf{Ejemplo Propuesto: Centralización de Validaciones}  
Aunque nuestra implementación actual gestiona las validaciones directamente en los métodos 
de las clases relevantes (\texttt{Adoptante}, \texttt{Donante}). Por ejemplo, podríamos considerar una 
clase auxiliar para centralizarlas en el futuro:

\begin{lstlisting}[style = javaEspecifico, language=Java, caption={Clase Auxiliar para Validaciones}] 
public class Validacion {
    public static void validarEstadoAnimal(Animal animal, EstadoAnimal estadoEsperado) {
        assert animal.getEstadoAnimal() == estadoEsperado : 
            "El estado del animal no coincide con el esperado.";
    }
}
\end{lstlisting}

En nuestra implementación actual, la validación se realiza directamente dentro de las clases:

\begin{lstlisting}[style = javaEspecifico, language=Java, caption={Manejo de validaciones dentro del método Adoptar}] 
public void adoptar(Animal a, Voluntario v) {
    assert a.getEstadoAnimal() == EstadoAnimal.DISPONIBLE : 
        "El animal no esta disponible.";
    Adopcion adopcion = new Adopcion(a, this, v, new Date());
    adopciones.add(adopcion);
}
\end{lstlisting}
\vspace{0.15cm}
\textbf{Decisión Tomada: Mantener las Validaciones en las Clases Relevantes}\par
En nuestra implementación actual, las validaciones se realizan directamente en las clases 
donde ocurren las operaciones. Esto se alinea con la claridad y simplicidad requeridas por 
el sistema. Sin embargo, reconocemos que la centralización de lógica compartida podría ser 
útil en sistemas más complejos. (ver los getters en Código~\ref{codigo:adopcion} por ejemplo)



\subsubsection{Representación de Relaciones en el Sistema}

\begin{description}
    \item[a)] \textbf{Relaciones Unidireccionales}
\end{description}

\textit{\textbf{Descripción:}}  
En una relación unidireccional, solo una entidad tiene conocimiento de la relación. 
Por ejemplo, un \texttt{Adoptante} puede conocer al \texttt{Animal} que adopta, 
pero el \texttt{Animal} no necesita saber nada sobre el \texttt{Adoptante}.

\begin{itemize}
    \item \textbf{Ventajas:}\par
    Son más simples de implementar, ya que solo una entidad gestiona la relación, 
    lo que reduce la complejidad del sistema.
    \item \textbf{Desventajas:}\par
    Pueden dar lugar a inconsistencias de datos si no se gestionan adecuadamente. 
    Además, las consultas entre entidades relacionadas pueden volverse más complejas 
    al no haber referencias explícitas.
\end{itemize}


\begin{description}
    \item[b)] \textbf{Relaciones Bidireccionales}
\end{description}

\textit{\textbf{Descripción:}}  
En una relación bidireccional, ambas entidades conocen y mantienen referencias mutuas. 
Por ejemplo, cuando un \texttt{Adoptante} adopta un \texttt{Animal}, ambos se actualizan 
mutuamente para reflejar la relación.

\begin{itemize}
    \item \textbf{Ventajas:}\par
    Garantizan la consistencia de los datos, ya que ambas partes relacionadas están 
    sincronizadas. Además, facilitan la gestión de relaciones complejas al mantener 
    referencias mutuas explícitas.
    \item \textbf{Desventajas:}\par
    Aumentan la complejidad del sistema al requerir sincronización constante entre las 
    entidades relacionadas, lo que puede dificultar el mantenimiento y afectar el 
    rendimiento en sistemas grandes.
\end{itemize}

\textbf{Ejemplo en el Sistema: Relaciones Bidireccionales en \texttt{Adopcion}}\par 
En nuestro diseño, la relación entre \texttt{Animal}, \texttt{Adoptante}, y 
\texttt{Voluntario} es bidireccional, asegurando consistencia en ambas direcciones.
(ver Código~\ref{codigo:adopcion} como se actualiza el estado del animal tras ser adoptado)\par
\vspace{0.15cm}
\textbf{Decisión Tomada: Relaciones Bidireccionales}\par
Hemos implementado relaciones bidireccionales para las asociaciones complejas del sistema, 
como las adopciones, ya que garantizan consistencia y sincronización entre las entidades 
relacionadas. Sin embargo, para relaciones más simples, como la lista de animales en un 
refugio, usamos relaciones unidireccionales para mantener la simplicidad.

\subsection{Diagrama de Diseño}

\begin{figure}[H]
    \centering
     \includegraphics[width=1\linewidth]{assets/umaLogo.png}
     \caption{UMA}
\end{figure}
FALTA HACER Y METER EL DIAGRAMA DE DISEÑO DE NUESTRO SISTEMA.RECOMENDABLE PONER UNA MINI EXPLICACIÓN.

\newpage



\subsection{Implementación del Modelo}
\input{body/ApartadoA/codigosApartadoA}

\subsection{Conclusión}

El diseño e implementación del código de andamiaje para el sistema se realizó siguiendo 
los principios fundamentales del diseño orientado a objetos, adaptados a los requerimientos 
específicos del de este apartado. Se tomaron la decisiones de diseño adecuadas, como la gestión 
de asociaciones entre clases, la encapsulación de datos y la validación restricciones con \texttt{assert}, 
proporcionando un modelo consistente y flexible.\par
\vspace{0.15cm}
Una de las decisiones clave fue el uso combinado de asociaciones directas para relaciones 
simples y la reificación de asociaciones para relaciones más complejas junto con \texttt{get}
con conjuntos inmutables. Esto permitió mantener un equilibrio entre la simplicidad de las 
implementaciones directas, como la gestión de animales en el refugio, y la flexibilidad 
de las relaciones complejas, como las adopciones, donde se requieren atributos adicionales 
y validaciones específicas mientras protegíamos las listas de cada objeto en el sistema.\par
\vspace{0.15cm}
Además, la bidireccionalidad en relaciones clave, como las adopciones, garantizó la 
consistencia del modelo al sincronizar automáticamente los datos entre entidades 
relacionadas.\par

\newpage
