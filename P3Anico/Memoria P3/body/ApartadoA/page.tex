\section{Diseño del código de andamiaje}

\subsection{Introducción}
En este apartado se discutirán las diferentes formas de diseñar el código de andamiaje necesario para implementar el modelo. Además, se incluirá un diagrama de diseño y la implementación en Java con la estrategia elegida, junto con la justificación de las decisiones tomadas.

\subsection{Formas de diseñar el código de andamiaje}
A continuación, se presentan las distintas estrategias consideradas para diseñar el código de andamiaje Java necesario para implementar el modelo:

\subsubsection{Estrategia 1: Uso de listas para manejar asociaciones 1:M}
\begin{itemize}
    \item \textbf{Descripción:} Esta estrategia consiste en representar las asociaciones 1:M mediante listas o colecciones genéricas.
    \item \textbf{Ventajas:}
    \begin{itemize}
        \item Sencillez de implementación.
        \item Flexibilidad al manejar elementos dinámicos.
    \end{itemize}
    \item \textbf{Desventajas:}
    \begin{itemize}
        \item Requiere validaciones adicionales para evitar duplicados.
        \item Incrementa la complejidad de las operaciones que necesitan acceso directo.
    \end{itemize}
\end{itemize}

\subsubsection{Estrategia 2: Uso de clases auxiliares para asociaciones}
\begin{itemize}
    \item \textbf{Descripción:} Aquí se implementan clases intermedias que representan asociaciones entre entidades.
    \item \textbf{Ventajas:}
    \begin{itemize}
        \item Mejora la legibilidad y modularidad del código.
        \item Facilita la adición de atributos a las relaciones.
    \end{itemize}
    \item \textbf{Desventajas:}
    \begin{itemize}
        \item Introduce complejidad adicional al modelo.
        \item Requiere una estructura más elaborada para manejar las asociaciones.
    \end{itemize}
\end{itemize}

\subsubsection{Estrategía 3: Uso de mapas para optimización}
\begin{itemize}
    \item \textbf{Descripción:} Utiliza mapas (\texttt{HashMap} o similares) para relacionar entidades de manera eficiente.
    \item \textbf{Ventajas:}
    \begin{itemize}
        \item Acceso rápido a elementos relacionados.
        \item Útil para casos donde las búsquedas son frecuentes.
    \end{itemize}
    \item \textbf{Desventajas:}
    \begin{itemize}
        \item Complejidad al sincronizar datos en estructuras grandes.
        \item Menor claridad en el código para relaciones simples.
    \end{itemize}
\end{itemize}

\subsection{Diagrama de diseño}
El siguiente diagrama ilustra la estructura del modelo con las asociaciones y atributos clave:

\begin{figure}[H]
    \centering
    %\includegraphics[width=1\linewidth]{} % Actualiza con la ruta de tu diagrama.
    \caption{Diagrama de diseño del modelo.}
    \label{fig:diagrama_diseno}
\end{figure}

\subsection{Implementación en Java}
A continuación, se muestra la implementación del modelo utilizando la estrategia seleccionada:

\subsubsection{Clase principal del modelo}
\begin{lstlisting}[language=Java]

   
\end{lstlisting}

\subsubsection{Clase auxiliar para asociaciones}
\begin{lstlisting}[language=Java]

\end{lstlisting}

\subsection{Justificación de la estrategia elegida}
Se ha seleccionado la estrategia de \textbf{[Nombre de la estrategia]} debido a las siguientes razones:
\begin{itemize}
    \item \textbf{Modularidad:} La estrategia seleccionada permite una mejor organización del código.
    \item \textbf{Escalabilidad:} Es más adecuada para manejar escenarios complejos y relaciones dinámicas.
    \item \textbf{Facilidad de mantenimiento:} La claridad y modularidad de esta implementación facilitan futuras actualizaciones del modelo.
\end{itemize}

\subsection{Conclusión}
El diseño y la implementación presentados cumplen con los requisitos del modelo, ofreciendo una solución balanceada entre eficiencia, claridad y escalabilidad.